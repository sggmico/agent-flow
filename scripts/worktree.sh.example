#!/bin/bash

# Agent Flow - Git Worktree ç®¡ç†è„šæœ¬
# ç”¨äºå¤š AI å¹¶è¡Œå¼€å‘ï¼ˆclaude-codeã€gemini-cliã€codex ç­‰ï¼‰

set -e

PROJECT_NAME="agent-flow"
WORKTREE_BASE="../"
BRANCH_PREFIX="dev"

# éœ€è¦è½¯é“¾æ¥å…±äº«çš„æ–‡ä»¶å’Œç›®å½•ï¼ˆä½¿ç”¨è½¯é“¾æ¥ï¼Œæ‰€æœ‰ worktree è‡ªåŠ¨åŒæ­¥ï¼‰
SHARED_ITEMS=(
  ".env"
)

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() {
  echo -e "${GREEN}âœ“${NC} $1"
}

print_warn() {
  echo -e "${YELLOW}âš ${NC} $1"
}

print_error() {
  echo -e "${RED}âœ—${NC} $1"
}

print_step() {
  echo -e "${BLUE}â–¸${NC} $1"
}

# æ˜¾ç¤ºä½¿ç”¨å¸®åŠ©
show_help() {
  cat <<EOF
ä½¿ç”¨æ–¹æ³•: ./worktree.sh <command> <ai-names...>

å‘½ä»¤:
  add <ai-names...>     åˆ›å»ºä¸€ä¸ªæˆ–å¤šä¸ª worktreeï¼ˆè‡ªåŠ¨å…±äº«é…ç½®ï¼‰
  remove <ai-names...>  åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ª worktree
  list                  åˆ—å‡ºæ‰€æœ‰ worktree
  status                æ˜¾ç¤ºå…±äº«æ–‡ä»¶çŠ¶æ€
  clean                 æ¸…ç†æ‰€æœ‰ worktree
  help                  æ˜¾ç¤ºå¸®åŠ©

å…±äº«é…ç½®ï¼ˆè½¯é“¾æ¥ï¼‰:
  .env, .claude/settings.local.json, docs/*_local/

ç¤ºä¾‹:
  ./worktree.sh add claude              # åˆ›å»ºå•ä¸ª
  ./worktree.sh add claude gemini codex # æ‰¹é‡åˆ›å»º
  ./worktree.sh remove claude gemini    # æ‰¹é‡åˆ é™¤
  ./worktree.sh status                  # æŸ¥çœ‹çŠ¶æ€
  ./worktree.sh list                    # åˆ—å‡ºæ‰€æœ‰
EOF
}

# ç¡®ä¿ä¸»ç›®å½•çš„å¿…è¦æ–‡ä»¶å­˜åœ¨
ensure_main_files() {
  local main_path=$(git rev-parse --show-toplevel)

  # å¦‚æœ .env ä¸å­˜åœ¨ï¼Œä» .env.example å¤åˆ¶
  if [ ! -f "$main_path/.env" ] && [ -f "$main_path/.env.example" ]; then
    print_step "ä¸»ç›®å½•ç¼ºå°‘ .envï¼Œæ­£åœ¨ä» .env.example å¤åˆ¶..."
    cp "$main_path/.env.example" "$main_path/.env"
    print_info ".env æ–‡ä»¶å·²åˆ›å»º"
    print_warn "è¯·ç¼–è¾‘ .env æ–‡ä»¶å¡«å…¥å®é™…é…ç½®"
  fi

  # ç¡®ä¿æœ¬åœ°ç›®å½•å­˜åœ¨
  for item in "docs/local" "docs/post_local" "docs/imgs_local" "docs/extend_local" "docs/changelog_local" "docs/idea_local"; do
    if [ ! -e "$main_path/$item" ]; then
      mkdir -p "$main_path/$item"
      print_info "åˆ›å»ºç›®å½•: $item"
    fi
  done

  # ç¡®ä¿ .claude ç›®å½•å­˜åœ¨
  if [ ! -d "$main_path/.claude" ]; then
    mkdir -p "$main_path/.claude"
  fi
}

# è®¡ç®—ç›¸å¯¹è·¯å¾„ï¼ˆå…¼å®¹ macOSï¼‰
get_relative_path() {
  local source=$1
  local target=$2
  python3 -c "import os.path; print(os.path.relpath('$source', '$target'))"
}

# åˆ›å»ºè½¯é“¾æ¥
create_symlinks() {
  local worktree_path=$1
  local main_path=$(git rev-parse --show-toplevel)

  echo ""
  print_step "æ­£åœ¨åˆ›å»ºè½¯é“¾æ¥ï¼ˆå…±äº«é…ç½®ï¼‰..."

  local link_count=0
  local skip_count=0

  for item in "${SHARED_ITEMS[@]}"; do
    local source_path="$main_path/$item"
    local target_path="$worktree_path/$item"
    local target_dir=$(dirname "$target_path")

    # å¦‚æœæºæ–‡ä»¶/ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡
    if [ ! -e "$source_path" ]; then
      print_warn "è·³è¿‡ $itemï¼ˆä¸»ç›®å½•ä¸­ä¸å­˜åœ¨ï¼‰"
      ((skip_count++))
      continue
    fi

    # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
    mkdir -p "$target_dir"

    # å¦‚æœç›®æ ‡å·²å­˜åœ¨ï¼ˆå¯èƒ½æ˜¯ git worktree åˆ›å»ºçš„ï¼‰ï¼Œå…ˆåˆ é™¤
    if [ -e "$target_path" ] || [ -L "$target_path" ]; then
      rm -rf "$target_path"
    fi

    # è®¡ç®—ç›¸å¯¹è·¯å¾„ï¼ˆä» target_dir åˆ° source_pathï¼‰
    # ä½¿ç”¨ Python è®¡ç®—ï¼Œå…¼å®¹ macOS å’Œ Linux
    local relative_path=$(get_relative_path "$source_path" "$target_dir")

    # åˆ›å»ºè½¯é“¾æ¥
    ln -s "$relative_path" "$target_path"

    if [ -L "$target_path" ]; then
      print_info "å·²é“¾æ¥: $item"
      ((link_count++))
    else
      print_error "é“¾æ¥å¤±è´¥: $item"
    fi
  done

  echo ""
  print_info "è½¯é“¾æ¥åˆ›å»ºå®Œæˆ: $link_count ä¸ªæˆåŠŸï¼Œ$skip_count ä¸ªè·³è¿‡"

  if [ $skip_count -gt 0 ]; then
    print_warn "éƒ¨åˆ†æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¯åœ¨ä¸»ç›®å½•åˆ›å»ºåè‡ªåŠ¨åŒæ­¥åˆ°æ‰€æœ‰ worktree"
  fi
}

# åˆ›å»º worktree
create_worktree() {
  local ai_name=$1
  local branch_name="${BRANCH_PREFIX}/${ai_name}"
  local worktree_path="${WORKTREE_BASE}${PROJECT_NAME}-${ai_name}"

  if [ -z "$ai_name" ]; then
    print_error "è¯·æŒ‡å®š AI åç§°"
    show_help
    exit 1
  fi

  # æ£€æŸ¥ worktree ç›®å½•æ˜¯å¦å·²å­˜åœ¨
  if [ -d "$worktree_path" ]; then
    print_error "Worktree ç›®å½•å·²å­˜åœ¨: $worktree_path"
    exit 1
  fi

  # ç¡®ä¿ä¸»ç›®å½•çš„å¿…è¦æ–‡ä»¶å­˜åœ¨
  ensure_main_files

  # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å·²å­˜åœ¨
  if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    print_warn "åˆ†æ”¯ $branch_name å·²å­˜åœ¨ï¼Œå°†ä½¿ç”¨ç°æœ‰åˆ†æ”¯"
    git worktree add "$worktree_path" "$branch_name"
  else
    print_info "åˆ›å»ºæ–°åˆ†æ”¯: $branch_name"
    git worktree add -b "$branch_name" "$worktree_path" main
  fi

  print_info "Worktree åˆ›å»ºæˆåŠŸ!"
  print_info "è·¯å¾„: $worktree_path"
  print_info "åˆ†æ”¯: $branch_name"

  # åˆ›å»ºè½¯é“¾æ¥
  create_symlinks "$worktree_path"

  echo ""
  print_info "==== å®Œæˆ ===="
  print_info "è¿›å…¥å·¥ä½œç›®å½•:"
  echo "  cd $worktree_path"
  echo ""
  print_info "å…±äº«é…ç½®è¯´æ˜:"
  echo "  - æ‰€æœ‰ worktree å…±äº«åŒä¸€ä»½ .env å’Œæœ¬åœ°æ–‡æ¡£"
  echo "  - ä¿®æ”¹ä»»æ„ worktree ä¸­çš„å…±äº«æ–‡ä»¶ï¼Œå…¶ä»– worktree è‡ªåŠ¨åŒæ­¥"
  echo "  - æŸ¥çœ‹å…±äº«çŠ¶æ€: ./worktree.sh status"
}

# åˆ é™¤ worktree
remove_worktree() {
  local ai_name=$1
  local branch_name="${BRANCH_PREFIX}/${ai_name}"
  local worktree_path="${WORKTREE_BASE}${PROJECT_NAME}-${ai_name}"

  if [ -z "$ai_name" ]; then
    print_error "è¯·æŒ‡å®š AI åç§°"
    show_help
    exit 1
  fi

  if [ ! -d "$worktree_path" ]; then
    print_error "Worktree ä¸å­˜åœ¨: $worktree_path"
    exit 1
  fi

  read -p "ç¡®è®¤åˆ é™¤ worktree '$ai_name'? (y/N) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git worktree remove "$worktree_path"
    print_info "Worktree å·²åˆ é™¤: $worktree_path"

    read -p "æ˜¯å¦åŒæ—¶åˆ é™¤åˆ†æ”¯ '$branch_name'? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git branch -D "$branch_name" 2>/dev/null || print_warn "åˆ†æ”¯ä¸å­˜åœ¨æˆ–å·²åˆ é™¤"
      print_info "åˆ†æ”¯å·²åˆ é™¤: $branch_name"
    fi
  else
    print_info "å–æ¶ˆåˆ é™¤"
  fi
}

# åˆ—å‡ºæ‰€æœ‰ worktree
list_worktrees() {
  print_info "å½“å‰æ‰€æœ‰ worktree:"
  echo ""
  git worktree list
}

# æ˜¾ç¤ºå…±äº«æ–‡ä»¶çŠ¶æ€
show_status() {
  local main_path=$(git rev-parse --show-toplevel)

  echo ""
  print_info "==== å…±äº«æ–‡ä»¶çŠ¶æ€ ===="
  echo ""

  print_step "ä¸»ç›®å½•è·¯å¾„: $main_path"
  echo ""

  # æ£€æŸ¥ä¸»ç›®å½•çš„å…±äº«æ–‡ä»¶
  print_step "ä¸»ç›®å½•å…±äº«æ–‡ä»¶:"
  for item in "${SHARED_ITEMS[@]}"; do
    local source_path="$main_path/$item"
    if [ -e "$source_path" ]; then
      if [ -d "$source_path" ]; then
        print_info "$item (ç›®å½•)"
      else
        print_info "$item (æ–‡ä»¶)"
      fi
    else
      print_warn "$item (ä¸å­˜åœ¨)"
    fi
  done

  # æ£€æŸ¥æ‰€æœ‰ worktree çš„é“¾æ¥çŠ¶æ€
  echo ""
  print_step "å„ worktree é“¾æ¥çŠ¶æ€:"

  git worktree list --porcelain | grep "worktree " | cut -d' ' -f2 | while read -r worktree_path; do
    # è·³è¿‡ä¸»ç›®å½•
    if [ "$worktree_path" = "$main_path" ]; then
      continue
    fi

    local worktree_name=$(basename "$worktree_path")
    echo ""
    echo "  ğŸ“ $worktree_name:"

    for item in "${SHARED_ITEMS[@]}"; do
      local target_path="$worktree_path/$item"
      if [ -L "$target_path" ]; then
        local link_target=$(readlink "$target_path")
        echo "    âœ“ $item -> $link_target"
      elif [ -e "$target_path" ]; then
        echo "    âš  $item (å­˜åœ¨ä½†ä¸æ˜¯è½¯é“¾æ¥)"
      else
        echo "    âœ— $item (ä¸å­˜åœ¨)"
      fi
    done
  done

  echo ""
  print_info "æç¤º: æ‰€æœ‰è½¯é“¾æ¥æŒ‡å‘ä¸»ç›®å½•ï¼Œä¿®æ”¹ä»»æ„å¤„ä¼šè‡ªåŠ¨åŒæ­¥"
}

# æ¸…ç†æ‰€æœ‰ worktreeï¼ˆä¿ç•™ä¸»ç›®å½•ï¼‰
clean_all_worktrees() {
  local main_path=$(git rev-parse --show-toplevel)

  read -p "ç¡®è®¤æ¸…ç†æ‰€æœ‰ worktree (ä¿ç•™ä¸»ç›®å½•)? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    print_info "å–æ¶ˆæ¸…ç†"
    exit 0
  fi

  git worktree list --porcelain | grep "worktree " | cut -d' ' -f2 | while read -r worktree_path; do
    if [ "$worktree_path" != "$main_path" ]; then
      print_info "åˆ é™¤: $worktree_path"
      git worktree remove "$worktree_path" --force
    fi
  done

  print_info "æ‰€æœ‰ worktree å·²æ¸…ç†"

  read -p "æ˜¯å¦åˆ é™¤æ‰€æœ‰ dev/* åˆ†æ”¯? (y/N) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git branch | grep "^  ${BRANCH_PREFIX}/" | sed 's/^  //' | while read -r branch; do
      print_info "åˆ é™¤åˆ†æ”¯: $branch"
      git branch -D "$branch"
    done
  fi
}

# æ‰¹é‡åˆ›å»º worktree
batch_create() {
  local total=$#
  local success=0
  local failed=0

  echo ""
  print_step "æ‰¹é‡åˆ›å»º $total ä¸ª worktree..."
  echo ""

  for ai_name in "$@"; do
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    print_step "[$((success + failed + 1))/$total] åˆ›å»º: $ai_name"
    echo ""

    if create_worktree "$ai_name"; then
      ((success++))
    else
      ((failed++))
    fi
    echo ""
  done

  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  print_info "==== æ‰¹é‡åˆ›å»ºå®Œæˆ ===="
  print_info "æˆåŠŸ: $success ä¸ª"
  if [ $failed -gt 0 ]; then
    print_warn "å¤±è´¥: $failed ä¸ª"
    return 1
  fi
  return 0
}

# æ‰¹é‡åˆ é™¤ worktree
batch_remove() {
  local total=$#

  echo ""
  print_info "å°†è¦åˆ é™¤çš„ worktree:"
  for ai_name in "$@"; do
    echo "  - $ai_name"
  done
  echo ""

  read -p "ç¡®è®¤æ‰¹é‡åˆ é™¤ä»¥ä¸Š worktree? (y/N) " -n 1 -r
  echo
  [[ ! $REPLY =~ ^[Yy]$ ]] && print_info "å–æ¶ˆåˆ é™¤" && exit 0

  read -p "æ˜¯å¦åŒæ—¶åˆ é™¤å¯¹åº”çš„åˆ†æ”¯? (y/N) " -n 1 -r
  echo
  local delete_branch=$REPLY

  local success=0
  local failed=0

  echo ""
  for ai_name in "$@"; do
    local branch_name="${BRANCH_PREFIX}/${ai_name}"
    local worktree_path="${WORKTREE_BASE}${PROJECT_NAME}-${ai_name}"

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    print_step "[$((success + failed + 1))/$total] åˆ é™¤: $ai_name"

    if [ ! -d "$worktree_path" ]; then
      print_warn "ä¸å­˜åœ¨: $worktree_path"
      ((failed++))
      continue
    fi

    if git worktree remove "$worktree_path" 2>/dev/null; then
      print_info "å·²åˆ é™¤: $worktree_path"
      [[ $delete_branch =~ ^[Yy]$ ]] && git branch -D "$branch_name" 2>/dev/null && print_info "åˆ†æ”¯å·²åˆ é™¤"
      ((success++))
    else
      print_error "åˆ é™¤å¤±è´¥"
      ((failed++))
    fi
    echo ""
  done

  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  print_info "==== æ‰¹é‡åˆ é™¤å®Œæˆ ===="
  print_info "æˆåŠŸ: $success ä¸ª"
  if [ $failed -gt 0 ]; then
    print_warn "å¤±è´¥: $failed ä¸ª"
    return 1
  fi
  return 0
}

# ä¸»é€»è¾‘
case "${1:-help}" in
  add)
    shift
    if [ $# -eq 0 ]; then
      print_error "è¯·æä¾›è‡³å°‘ä¸€ä¸ª AI åç§°"
      exit 1
    elif [ $# -gt 1 ]; then
      batch_create "$@"
    else
      create_worktree "$1"
    fi
    ;;
  remove|rm)
    shift
    if [ $# -eq 0 ]; then
      print_error "è¯·æä¾›è‡³å°‘ä¸€ä¸ª AI åç§°"
      exit 1
    elif [ $# -gt 1 ]; then
      batch_remove "$@"
    else
      remove_worktree "$1"
    fi
    ;;
  list|ls)
    list_worktrees
    ;;
  status|st)
    show_status
    ;;
  clean)
    clean_all_worktrees
    ;;
  help|--help|-h)
    show_help
    ;;
  *)
    print_error "æœªçŸ¥å‘½ä»¤: $1"
    echo ""
    show_help
    exit 1
    ;;
esac
