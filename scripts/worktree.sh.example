#!/bin/bash

# Agent Flow - Git Worktree ç®¡ç†è„šæœ¬
# ç”¨äºå¤š AI å¹¶è¡Œå¼€å‘ï¼ˆclaude-codeã€gemini-cliã€codex ç­‰ï¼‰

set -e

PROJECT_NAME="agent-flow"
WORKTREE_BASE="../"
BRANCH_PREFIX="dev"

# éœ€è¦è½¯é“¾æ¥å…±äº«çš„æ–‡ä»¶å’Œç›®å½•ï¼ˆä½¿ç”¨è½¯é“¾æ¥ï¼Œæ‰€æœ‰ worktree è‡ªåŠ¨åŒæ­¥ï¼‰
SHARED_ITEMS=(
  ".env"
)

# é¢œè‰²è¾“å‡º
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() {
  echo -e "${GREEN}âœ“${NC} $1"
}

print_warn() {
  echo -e "${YELLOW}âš ${NC} $1"
}

print_error() {
  echo -e "${RED}âœ—${NC} $1"
}

print_step() {
  echo -e "${BLUE}â–¸${NC} $1"
}

# æ˜¾ç¤ºä½¿ç”¨å¸®åŠ©
show_help() {
  cat <<EOF
ä½¿ç”¨æ–¹æ³•: ./worktree.sh <command> [ai-name]

å‘½ä»¤:
  add <ai-name>     åˆ›å»ºæ–°çš„ worktreeï¼ˆè‡ªåŠ¨è½¯é“¾æ¥å…±äº«é…ç½®ï¼‰
  remove <ai-name>  åˆ é™¤æŒ‡å®šçš„ worktree
  list              åˆ—å‡ºæ‰€æœ‰ worktree
  status            æ˜¾ç¤ºå…±äº«æ–‡ä»¶çŠ¶æ€
  clean             æ¸…ç†æ‰€æœ‰ worktree
  help              æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯

AI åç§°ç¤ºä¾‹:
  claude    -> åˆ›å»º dev/claude åˆ†æ”¯å’Œ agent-flow-claude ç›®å½•
  gemini    -> åˆ›å»º dev/gemini åˆ†æ”¯å’Œ agent-flow-gemini ç›®å½•
  codex     -> åˆ›å»º dev/codex åˆ†æ”¯å’Œ agent-flow-codex ç›®å½•

å…±äº«ç­–ç•¥ï¼ˆæ–¹æ¡ˆä¸€ï¼šè½¯é“¾æ¥å…±äº«ï¼‰:
  ä»¥ä¸‹æ–‡ä»¶/ç›®å½•å°†è‡ªåŠ¨åˆ›å»ºè½¯é“¾æ¥ï¼Œæ‰€æœ‰ worktree è‡ªåŠ¨åŒæ­¥ï¼š
  - .envï¼ˆç¯å¢ƒå˜é‡é…ç½®ï¼‰
  - .claude/settings.local.jsonï¼ˆClaude è®¾ç½®ï¼‰
  - docs/*_local/ï¼ˆæœ¬åœ°æ–‡æ¡£ç›®å½•ï¼‰

ç¤ºä¾‹:
  ./worktree.sh add claude
  ./worktree.sh add gemini
  ./worktree.sh status
  ./worktree.sh list
  ./worktree.sh remove claude
  ./worktree.sh clean
EOF
}

# ç¡®ä¿ä¸»ç›®å½•çš„å¿…è¦æ–‡ä»¶å­˜åœ¨
ensure_main_files() {
  local main_path=$(git rev-parse --show-toplevel)

  # å¦‚æœ .env ä¸å­˜åœ¨ï¼Œä» .env.example å¤åˆ¶
  if [ ! -f "$main_path/.env" ] && [ -f "$main_path/.env.example" ]; then
    print_step "ä¸»ç›®å½•ç¼ºå°‘ .envï¼Œæ­£åœ¨ä» .env.example å¤åˆ¶..."
    cp "$main_path/.env.example" "$main_path/.env"
    print_info ".env æ–‡ä»¶å·²åˆ›å»º"
    print_warn "è¯·ç¼–è¾‘ .env æ–‡ä»¶å¡«å…¥å®é™…é…ç½®"
  fi

  # ç¡®ä¿æœ¬åœ°ç›®å½•å­˜åœ¨
  for item in "docs/local" "docs/post_local" "docs/imgs_local" "docs/extend_local" "docs/changelog_local" "docs/idea_local"; do
    if [ ! -e "$main_path/$item" ]; then
      mkdir -p "$main_path/$item"
      print_info "åˆ›å»ºç›®å½•: $item"
    fi
  done

  # ç¡®ä¿ .claude ç›®å½•å­˜åœ¨
  if [ ! -d "$main_path/.claude" ]; then
    mkdir -p "$main_path/.claude"
  fi
}

# è®¡ç®—ç›¸å¯¹è·¯å¾„ï¼ˆå…¼å®¹ macOSï¼‰
get_relative_path() {
  local source=$1
  local target=$2
  python3 -c "import os.path; print(os.path.relpath('$source', '$target'))"
}

# åˆ›å»ºè½¯é“¾æ¥
create_symlinks() {
  local worktree_path=$1
  local main_path=$(git rev-parse --show-toplevel)

  echo ""
  print_step "æ­£åœ¨åˆ›å»ºè½¯é“¾æ¥ï¼ˆå…±äº«é…ç½®ï¼‰..."

  local link_count=0
  local skip_count=0

  for item in "${SHARED_ITEMS[@]}"; do
    local source_path="$main_path/$item"
    local target_path="$worktree_path/$item"
    local target_dir=$(dirname "$target_path")

    # å¦‚æœæºæ–‡ä»¶/ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡
    if [ ! -e "$source_path" ]; then
      print_warn "è·³è¿‡ $itemï¼ˆä¸»ç›®å½•ä¸­ä¸å­˜åœ¨ï¼‰"
      ((skip_count++))
      continue
    fi

    # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
    mkdir -p "$target_dir"

    # å¦‚æœç›®æ ‡å·²å­˜åœ¨ï¼ˆå¯èƒ½æ˜¯ git worktree åˆ›å»ºçš„ï¼‰ï¼Œå…ˆåˆ é™¤
    if [ -e "$target_path" ] || [ -L "$target_path" ]; then
      rm -rf "$target_path"
    fi

    # è®¡ç®—ç›¸å¯¹è·¯å¾„ï¼ˆä» target_dir åˆ° source_pathï¼‰
    # ä½¿ç”¨ Python è®¡ç®—ï¼Œå…¼å®¹ macOS å’Œ Linux
    local relative_path=$(get_relative_path "$source_path" "$target_dir")

    # åˆ›å»ºè½¯é“¾æ¥
    ln -s "$relative_path" "$target_path"

    if [ -L "$target_path" ]; then
      print_info "å·²é“¾æ¥: $item"
      ((link_count++))
    else
      print_error "é“¾æ¥å¤±è´¥: $item"
    fi
  done

  echo ""
  print_info "è½¯é“¾æ¥åˆ›å»ºå®Œæˆ: $link_count ä¸ªæˆåŠŸï¼Œ$skip_count ä¸ªè·³è¿‡"

  if [ $skip_count -gt 0 ]; then
    print_warn "éƒ¨åˆ†æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¯åœ¨ä¸»ç›®å½•åˆ›å»ºåè‡ªåŠ¨åŒæ­¥åˆ°æ‰€æœ‰ worktree"
  fi
}

# åˆ›å»º worktree
create_worktree() {
  local ai_name=$1
  local branch_name="${BRANCH_PREFIX}/${ai_name}"
  local worktree_path="${WORKTREE_BASE}${PROJECT_NAME}-${ai_name}"

  if [ -z "$ai_name" ]; then
    print_error "è¯·æŒ‡å®š AI åç§°"
    show_help
    exit 1
  fi

  # æ£€æŸ¥ worktree ç›®å½•æ˜¯å¦å·²å­˜åœ¨
  if [ -d "$worktree_path" ]; then
    print_error "Worktree ç›®å½•å·²å­˜åœ¨: $worktree_path"
    exit 1
  fi

  # ç¡®ä¿ä¸»ç›®å½•çš„å¿…è¦æ–‡ä»¶å­˜åœ¨
  ensure_main_files

  # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å·²å­˜åœ¨
  if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    print_warn "åˆ†æ”¯ $branch_name å·²å­˜åœ¨ï¼Œå°†ä½¿ç”¨ç°æœ‰åˆ†æ”¯"
    git worktree add "$worktree_path" "$branch_name"
  else
    print_info "åˆ›å»ºæ–°åˆ†æ”¯: $branch_name"
    git worktree add -b "$branch_name" "$worktree_path" main
  fi

  print_info "Worktree åˆ›å»ºæˆåŠŸ!"
  print_info "è·¯å¾„: $worktree_path"
  print_info "åˆ†æ”¯: $branch_name"

  # åˆ›å»ºè½¯é“¾æ¥
  create_symlinks "$worktree_path"

  echo ""
  print_info "==== å®Œæˆ ===="
  print_info "è¿›å…¥å·¥ä½œç›®å½•:"
  echo "  cd $worktree_path"
  echo ""
  print_info "å…±äº«é…ç½®è¯´æ˜:"
  echo "  - æ‰€æœ‰ worktree å…±äº«åŒä¸€ä»½ .env å’Œæœ¬åœ°æ–‡æ¡£"
  echo "  - ä¿®æ”¹ä»»æ„ worktree ä¸­çš„å…±äº«æ–‡ä»¶ï¼Œå…¶ä»– worktree è‡ªåŠ¨åŒæ­¥"
  echo "  - æŸ¥çœ‹å…±äº«çŠ¶æ€: ./worktree.sh status"
}

# åˆ é™¤ worktree
remove_worktree() {
  local ai_name=$1
  local branch_name="${BRANCH_PREFIX}/${ai_name}"
  local worktree_path="${WORKTREE_BASE}${PROJECT_NAME}-${ai_name}"

  if [ -z "$ai_name" ]; then
    print_error "è¯·æŒ‡å®š AI åç§°"
    show_help
    exit 1
  fi

  if [ ! -d "$worktree_path" ]; then
    print_error "Worktree ä¸å­˜åœ¨: $worktree_path"
    exit 1
  fi

  read -p "ç¡®è®¤åˆ é™¤ worktree '$ai_name'? (y/N) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git worktree remove "$worktree_path"
    print_info "Worktree å·²åˆ é™¤: $worktree_path"

    read -p "æ˜¯å¦åŒæ—¶åˆ é™¤åˆ†æ”¯ '$branch_name'? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      git branch -D "$branch_name" 2>/dev/null || print_warn "åˆ†æ”¯ä¸å­˜åœ¨æˆ–å·²åˆ é™¤"
      print_info "åˆ†æ”¯å·²åˆ é™¤: $branch_name"
    fi
  else
    print_info "å–æ¶ˆåˆ é™¤"
  fi
}

# åˆ—å‡ºæ‰€æœ‰ worktree
list_worktrees() {
  print_info "å½“å‰æ‰€æœ‰ worktree:"
  echo ""
  git worktree list
}

# æ˜¾ç¤ºå…±äº«æ–‡ä»¶çŠ¶æ€
show_status() {
  local main_path=$(git rev-parse --show-toplevel)

  echo ""
  print_info "==== å…±äº«æ–‡ä»¶çŠ¶æ€ ===="
  echo ""

  print_step "ä¸»ç›®å½•è·¯å¾„: $main_path"
  echo ""

  # æ£€æŸ¥ä¸»ç›®å½•çš„å…±äº«æ–‡ä»¶
  print_step "ä¸»ç›®å½•å…±äº«æ–‡ä»¶:"
  for item in "${SHARED_ITEMS[@]}"; do
    local source_path="$main_path/$item"
    if [ -e "$source_path" ]; then
      if [ -d "$source_path" ]; then
        print_info "$item (ç›®å½•)"
      else
        print_info "$item (æ–‡ä»¶)"
      fi
    else
      print_warn "$item (ä¸å­˜åœ¨)"
    fi
  done

  # æ£€æŸ¥æ‰€æœ‰ worktree çš„é“¾æ¥çŠ¶æ€
  echo ""
  print_step "å„ worktree é“¾æ¥çŠ¶æ€:"

  git worktree list --porcelain | grep "worktree " | cut -d' ' -f2 | while read -r worktree_path; do
    # è·³è¿‡ä¸»ç›®å½•
    if [ "$worktree_path" = "$main_path" ]; then
      continue
    fi

    local worktree_name=$(basename "$worktree_path")
    echo ""
    echo "  ğŸ“ $worktree_name:"

    for item in "${SHARED_ITEMS[@]}"; do
      local target_path="$worktree_path/$item"
      if [ -L "$target_path" ]; then
        local link_target=$(readlink "$target_path")
        echo "    âœ“ $item -> $link_target"
      elif [ -e "$target_path" ]; then
        echo "    âš  $item (å­˜åœ¨ä½†ä¸æ˜¯è½¯é“¾æ¥)"
      else
        echo "    âœ— $item (ä¸å­˜åœ¨)"
      fi
    done
  done

  echo ""
  print_info "æç¤º: æ‰€æœ‰è½¯é“¾æ¥æŒ‡å‘ä¸»ç›®å½•ï¼Œä¿®æ”¹ä»»æ„å¤„ä¼šè‡ªåŠ¨åŒæ­¥"
}

# æ¸…ç†æ‰€æœ‰ worktreeï¼ˆä¿ç•™ä¸»ç›®å½•ï¼‰
clean_all_worktrees() {
  local main_path=$(git rev-parse --show-toplevel)

  read -p "ç¡®è®¤æ¸…ç†æ‰€æœ‰ worktree (ä¿ç•™ä¸»ç›®å½•)? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    print_info "å–æ¶ˆæ¸…ç†"
    exit 0
  fi

  git worktree list --porcelain | grep "worktree " | cut -d' ' -f2 | while read -r worktree_path; do
    if [ "$worktree_path" != "$main_path" ]; then
      print_info "åˆ é™¤: $worktree_path"
      git worktree remove "$worktree_path" --force
    fi
  done

  print_info "æ‰€æœ‰ worktree å·²æ¸…ç†"

  read -p "æ˜¯å¦åˆ é™¤æ‰€æœ‰ dev/* åˆ†æ”¯? (y/N) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git branch | grep "^  ${BRANCH_PREFIX}/" | sed 's/^  //' | while read -r branch; do
      print_info "åˆ é™¤åˆ†æ”¯: $branch"
      git branch -D "$branch"
    done
  fi
}

# ä¸»é€»è¾‘
case "${1:-help}" in
  add)
    create_worktree "$2"
    ;;
  remove|rm)
    remove_worktree "$2"
    ;;
  list|ls)
    list_worktrees
    ;;
  status|st)
    show_status
    ;;
  clean)
    clean_all_worktrees
    ;;
  help|--help|-h)
    show_help
    ;;
  *)
    print_error "æœªçŸ¥å‘½ä»¤: $1"
    echo ""
    show_help
    exit 1
    ;;
esac
